# Planning with Files 项目分析

## 概述

Planning with Files 是一个实现 Manus AI "上下文工程"模式的 Claude Code 技能/插件。该项目的核心理念来自被 Meta 以 20 亿美元收购的 AI 初创公司 Manus，其创新之处在于将文件系统用作 AI 智能体的"工作记忆"，而非依赖易失的上下文窗口。

**项目地址**: https://github.com/OthmanAdi/planning-with-files

**当前版本**: 2.6.0

## 核心问题与解决方案

### 问题：AI 智能体的记忆困境

AI 智能体在执行复杂任务时面临几个关键问题：

1. **目标漂移 (Lost in the Middle)**：经过 50+ 次工具调用后，模型容易忘记原始目标
2. **错误重复**：隐藏的错误导致相同问题反复出现
3. **多模态信息丢失**：图像、PDF、浏览器内容在上下文重置时不会持久化
4. **上下文限制**：信息只在上下文窗口中堆积，而不是被持久化存储

### 解决方案：核心公式

```
上下文窗口 = RAM (易失，有限)
文件系统   = 磁盘 (持久，无限)

→ 所有重要内容都要写入磁盘
```

## 3 文件模式

Planning with Files 采用 3 个 Markdown 文件作为持久化的外部记忆：

| 文件 | 用途 | 更新时机 |
|------|------|---------|
| `task_plan.md` | 任务路线图，跟踪阶段和进度 | 每个阶段完成后 |
| `findings.md` | 存储研究发现和技术决策 | 每次发现后（遵循 2-操作规则） |
| `progress.md` | 会话日志和测试结果 | 全程维护 |

### task_plan.md 结构

```markdown
## Goal
[一句话描述最终目标]

## Current Phase
Phase 1

## Phases
### Phase 1: Requirements & Discovery
- [ ] 理解用户意图
- [ ] 识别约束和需求
- **Status:** in_progress

### Phase 2: Planning & Structure
- **Status:** pending

### Phase 3: Implementation
- **Status:** pending

## Key Questions
1. [需要回答的问题]

## Decisions Made
| Decision | Rationale |
|----------|-----------|

## Errors Encountered
| Error | Attempt | Resolution |
|-------|---------|------------|
```

### findings.md 结构

用于存储：
- 用户需求的具体分解
- Web 搜索和文档阅读的关键发现
- 架构和实现选择及其理由
- 遇到的问题和解决方案
- URLs、文件路径、API 参考

### progress.md 结构

用于记录：
- 每次会话的日期
- 各阶段的详细日志
- 测试输入/预期/实际/状态
- 带时间戳的错误详细日志

## Manus 6 大核心原则

### 原则 1：围绕 KV-Cache 设计

> "KV-cache 命中率是生产级 AI 智能体最重要的指标。"

**关键数据**：
- 缓存令牌成本：$0.30/百万
- 未缓存令牌成本：$3/百万
- **10 倍成本差异！**

**实现方式**：
- 保持提示前缀稳定（单个 token 变化就会使缓存失效）
- 系统提示中不要使用时间戳
- 使用确定性序列化使上下文仅追加

### 原则 2：遮蔽而不是移除

不要动态移除工具（会破坏 KV-cache），而是使用逻辑遮蔽。

### 原则 3：文件系统作为外部记忆

> "Markdown 是我'工作记忆在磁盘上'。"

压缩必须可恢复：
- 即使丢弃网页内容，也要保留 URL
- 即使丢弃文档内容，也要保留文件路径
- 永远不要丢失指向完整数据的指针

### 原则 4：通过背诵操纵注意力

**问题**：经过约 50 次工具调用后，模型会忘记原始目标（"lost in the middle" 效应）。

**解决方案**：在每次决策前重新读取 `task_plan.md`。

```
上下文开始: [原始目标 - 很远，被遗忘]
...很多工具调用...
上下文结束: [刚刚读取的 task_plan.md - 获得注意力！]
```

### 原则 5：保留错误的内容

> "把错误的转弯保留在上下文中。"

**原因**：
- 失败的操作和堆栈跟踪让模型隐式更新信念
- 减少错误重复
- "错误恢复是真正的智能体行为的最清晰信号"

### 原则 6：不要被少量示例欺骗

> "统一性滋生脆弱性。"

**问题**：重复的 action-observation 对导致漂移和幻觉。

**解决方案**：引入受控的变化，避免盲目复制粘贴模式。

## Hook 机制

Planning with Files 通过 3 种 Hook 实现自动化的上下文管理：

### PreToolUse Hook

**触发时机**：在 Write/Edit/Bash/Read/Glob/Grep 前执行

**执行内容**：
```bash
cat task_plan.md 2>/dev/null | head -30 || true
```

**作用**：
- 在每次重要操作前读取 task_plan.md 的前 30 行
- 将目标刷新到注意力窗口
- 防止"lost in the middle"效应

### PostToolUse Hook

**触发时机**：在 Write/Edit 后执行

**执行内容**：
```bash
echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'
```

**作用**：
- 提醒更新 task_plan.md 的阶段状态

### Stop Hook

**触发时机**：在停止工作前执行

**执行内容**：运行 `check-complete.sh` 脚本

**作用**：
- 验证 task_plan.md 中所有阶段是否都标记为 "complete"
- 如果不完整，阻止停止工作

```bash
# check-complete.sh 核心逻辑
total=$(grep -c "### Phase" task_plan.md)
complete=$(grep -c "**Status:** complete" task_plan.md)
if [ "$complete" -eq "$total" ]; then
    exit 0  # 允许停止
else
    exit 1  # 阻止停止
fi
```

## 关键规则

### 2-操作规则

> "每 2 次查看/浏览/搜索操作后，**必须立即**更新 findings.md"

**原因**：多模态内容（图像、浏览器结果）在上下文重置时不会持久化。

**示例**：
```
操作 1：WebSearch  → 记录结果
操作 2：WebFetch   → 必须现在更新 findings.md！
操作 3：Read 文件  → 记录发现
操作 4：Grep 搜索  → 必须现在更新 findings.md！
```

### 3-Strike 错误协议

```
尝试 1：诊断并修复
  → 仔细阅读错误
  → 确定根本原因
  → 应用有针对性的修复

尝试 2：备选方法
  → 如果相同错误？尝试不同的方法
  → 不同的工具？不同的库？
  → 永远不要重复确切的失败操作

尝试 3：更广泛的重新思考
  → 质疑假设
  → 搜索解决方案
  → 考虑更新计划

3 次后失败：上报给用户
  → 解释您尝试了什么
  → 分享具体错误
  → 请求指导
```

### 5 问重启测试

如果能回答这 5 个问题，说明上下文管理是坚实的：

| 问题 | 答案来源 |
|------|---------|
| 我在哪里？ | task_plan.md 中的当前阶段 |
| 我要去哪里？ | 剩余阶段 |
| 目标是什么？ | task_plan.md 中的目标声明 |
| 我学到了什么？ | findings.md |
| 我做了什么？ | progress.md |

## 会话恢复功能 (v2.2.0+)

**问题**：上下文填满时，运行 `/clear` 会丢失未同步的工作。

**解决方案**：`session-catchup.py` 脚本

**工作原理**：
1. 扫描 `~/.claude/projects/` 的会话 JSONL 文件
2. 定位规划文件的最后更新
3. 提取并显示之后的所有对话（最后 15 条消息）
4. 生成赶上报告，建议更新规划文件

## 核心价值

1. **防止目标漂移**：PreToolUse hook 在每次决策前刷新目标
2. **减少错误重复**：所有错误都被持久化和记录
3. **多模态信息持久化**：2-操作规则确保视觉/浏览器信息不丢失
4. **任务完整性保证**：Stop hook 验证所有阶段完成才允许结束
5. **无损会话恢复**：运行 `/clear` 后自动恢复未同步的上下文

## 适用场景

**适合使用**：
- 多步骤任务（3+ 步骤）
- 研究任务
- 构建/创建项目
- 跨越多次工具调用的任务
- 任何需要组织的工作

**不适合使用**：
- 简单问题
- 单文件编辑
- 快速查询

## 反模式

| 不要 | 应该 |
|------|------|
| 使用 TodoWrite 进行持久化 | 创建 task_plan.md 文件 |
| 只说一次目标然后忘记 | 在决策前重新读取计划 |
| 隐藏错误并静默重试 | 将错误记录到计划文件 |
| 把所有内容塞进上下文 | 将大型内容存储在文件中 |
| 立即开始执行 | 首先创建计划文件 |
| 重复失败的操作 | 跟踪尝试，改变方法 |

## 总结

Planning with Files 代表了 AI 工作流程优化的最佳实践。它的核心创新是将文件系统用作持久化外部记忆，补充易失的上下文窗口。通过 Hook 机制自动化上下文管理，确保 AI 智能体在执行复杂、多步骤任务时保持目标聚焦和错误学习能力。

这种方法特别适合需要：
- 持久化进度跟踪
- 错误恢复
- 跨会话工作连续性
- 复杂任务分解和执行

的场景。
