# Working State Pattern

> **核心理念**：一个精简的主文件掌控全局，详细内容按需存储在引用文件中。
>
> **设计哲学**：指针不丢，详情按需。

---

## 概述

Working State Pattern 是一种面向 AI Agent 的上下文工程方法。它的核心思想来自一个简单的类比：

```
Context Window = RAM（易失、有限）
Filesystem = Disk（持久、无限）

→ 重要信息写入磁盘
→ 主文件保持精简
→ 详情按需加载
```

### 解决的问题

| 问题 | 表现 | 解决方案 |
|------|------|---------|
| 目标漂移 | 50+ 工具调用后忘记原始目标 | 主文件记录目标，重大操作前重读 |
| 上下文爆炸 | 所有信息塞入上下文窗口 | 详情存入引用文件，主文件只留摘要 |
| 错误重复 | 反复踩同样的坑 | 所有错误记录在案，永不重复 |
| 会话断裂 | 上下文清空后丢失进度 | 文件持久化，随时可恢复 |

---

## 核心原则

### 原则 1：主文件是注意力焦点

主文件 `working_state.md` 是整个任务的控制中心：

- 控制在 **100-200 行以内**
- 包含所有关键状态和决策
- 一屏可以扫描完毕
- **每次重大操作前重读**，把目标刷新到注意力窗口

```
开始工作 → Read working_state.md → 执行任务 → 更新 working_state.md
```

### 原则 2：摘要在主文件，详情在引用

当内容过多时，主文件只保留**摘要 + 引用路径**：

```markdown
## 研究发现
- **OAuth 2.0**: 授权码流程适合我们的场景 → [详细笔记](refs/research_oauth.md)
```

看这一行就知道：
1. 研究过什么（OAuth 2.0）
2. 结论是什么（授权码流程适合）
3. 详情在哪（refs/research_oauth.md）

### 原则 3：按需创建，按需读取

不预先创建所有文件，遵循：

```
内容超过阈值 → 创建引用文件 → 主文件保留摘要+路径
需要详情时 → 读取引用文件
不需要时 → 主文件的摘要足够
```

### 原则 4：指针永不丢失

即使不读取引用文件，路径本身就是有价值的信息：

- 说明这个内容**存在**
- 说明它在**哪里**
- 需要时可以**找回**

```markdown
- **内存泄漏排查**: 修复了事件监听器问题 → [排查过程](refs/debug_memory_leak.md)
```

即使不读 `debug_memory_leak.md`，也知道这个问题已解决，详细过程有记录。

### 原则 5：错误必须记录

每个错误都要写入主文件：

```markdown
## 错误日志
| 错误 | 尝试 | 解决方案 |
|------|------|---------|
| TokenExpiredError | 1 | 添加刷新逻辑 |
| ImportError | 1 | 安装缺失依赖 |
```

**规则**：`if action_failed: next_action != same_action`

记录失败，变换方法，永不重复。

---

## 文件结构

### 目录布局

```
project/
├── working_state.md           # 核心主文件
├── refs/                      # 引用文件目录
│   ├── research_[主题].md     # 研究笔记
│   ├── analysis_[对象].md     # 代码/系统分析
│   ├── session_[日期].md      # 会话日志
│   ├── debug_[问题].md        # 问题排查记录
│   └── decision_[决策].md     # 重大决策详细记录
└── ... (项目其他文件)
```

### 引用文件命名约定

| 前缀 | 用途 | 示例 |
|------|------|------|
| `research_` | 技术研究、文档阅读笔记 | `research_oauth.md` |
| `analysis_` | 代码分析、架构分析 | `analysis_auth_module.md` |
| `session_` | 会话工作日志 | `session_0122.md` |
| `debug_` | 复杂问题排查过程 | `debug_memory_leak.md` |
| `decision_` | 重大架构/技术决策 | `decision_database_choice.md` |

---

## 主文件模板

```markdown
# 工作状态 (Working State)

## 目标
<!-- 一句话描述最终要达成的状态 -->
[清晰的目标陈述]

## 当前阶段
<!-- 快速定位当前在哪 -->
Phase X: [阶段名称]

## 阶段进度
<!--
  状态图标：⏸️ 待做 | 🔄 进行中 | ✅ 完成 | ❌ 失败 | ⏭️ 跳过
-->
- [x] Phase 1: 需求理解 | ✅
- [x] Phase 2: 方案设计 | ✅
- [ ] Phase 3: 核心实现 | 🔄 ← 当前
- [ ] Phase 4: 测试验证 | ⏸️
- [ ] Phase 5: 交付确认 | ⏸️

## 关键问题
<!-- 需要回答的核心问题 -->
1. [问题1]? → [答案/状态]
2. [问题2]? → [答案/状态]

## 关键决策
<!-- 重大选择及其理由 -->
| 决策 | 理由 | 详情 |
|------|------|------|
| 使用 JWT 认证 | 无状态，易扩展 | - |
| 选择 PostgreSQL | 复杂查询支持 | [详细分析](refs/decision_database.md) |

## 研究发现
<!--
  格式：**主题**: 一句话摘要 → [详细](refs/xxx.md)
-->
- **OAuth 2.0 流程**: 授权码流程适合我们的场景 → [详细](refs/research_oauth.md)
- **现有认证模块**: 需要重构，耦合度高 → [分析](refs/analysis_auth.md)

## 错误日志
<!-- 所有错误的单一记录点 -->
| 错误 | 尝试 | 解决方案 | 详情 |
|------|------|---------|------|
| TokenExpiredError | 1 | 添加刷新逻辑 | - |
| 内存泄漏 | 3 | 修复事件监听器 | [排查过程](refs/debug_memory.md) |

## 当前会话
<!-- 今天的工作记录 -->
### 2026-01-22
- 10:00 开始 Phase 3
- 10:30 创建 auth.py 基础结构
- 11:00 实现 JWT 生成逻辑
- 11:30 遇到 TokenExpiredError，已解决

## 历史会话
<!-- 往期会话的引用 -->
- 2026-01-21: 完成 Phase 1-2 → [日志](refs/session_0121.md)
- 2026-01-20: 项目启动 → [日志](refs/session_0120.md)

## 待办事项
<!-- 当前阶段的具体任务 -->
- [ ] 实现 access token 生成
- [ ] 实现 refresh token 逻辑
- [ ] 添加 token 验证中间件

---
<!--
  5 问题重启测试：
  1. 我在哪？ → 当前阶段
  2. 要去哪？ → 剩余阶段
  3. 目标是什么？ → 目标声明
  4. 学到了什么？ → 研究发现
  5. 做了什么？ → 当前会话 + 历史会话
-->
```

---

## 引用文件模板

### 研究笔记 (research_*.md)

```markdown
# 研究笔记: [主题]

> 创建时间: YYYY-MM-DD
> 关联主文件: ../working_state.md

## 摘要
<!-- 同步到主文件的内容 -->
[1-2 句话的核心结论]

## 研究背景
- 问题/需求描述
- 研究目标

## 详细发现

### 发现 1: [小标题]
[详细内容]

### 发现 2: [小标题]
[详细内容]

## 资源链接
- [官方文档](url)
- [参考文章](url)

## 结论与建议
[对主任务的影响和建议]
```

### 会话日志 (session_*.md)

```markdown
# 会话日志: YYYY-MM-DD

> 关联主文件: ../working_state.md

## 会话概要
<!-- 同步到主文件的历史会话 -->
- 主要完成: [简述]
- 当前状态: Phase X 进行中/完成

## 详细时间线

### 10:00 - 开始工作
- 阅读主文件，确认当前状态
- 目标：完成 [具体目标]

### 10:30 - [活动描述]
- 执行了什么操作
- 结果如何
- 创建/修改的文件：
  - `path/to/file1.py`
  - `path/to/file2.py`

### 11:00 - 遇到问题
- 问题描述
- 尝试的解决方案
- 最终解决方式

## 创建/修改的文件
| 文件 | 操作 | 说明 |
|------|------|------|
| src/auth.py | 创建 | JWT 认证核心逻辑 |
| src/middleware.py | 修改 | 添加认证中间件 |

## 下次继续
- [ ] 待完成任务 1
- [ ] 待完成任务 2
```

### 问题排查 (debug_*.md)

```markdown
# 问题排查: [问题简述]

> 创建时间: YYYY-MM-DD
> 关联主文件: ../working_state.md
> 状态: 已解决 / 进行中

## 问题描述
- 现象：[具体表现]
- 错误信息：[完整错误]
- 复现条件：[如何触发]

## 排查过程

### 尝试 1: [方法描述]
- 假设：[为什么尝试这个]
- 操作：[具体做了什么]
- 结果：❌ 失败 / ✅ 成功
- 学到：[这次尝试的收获]

### 尝试 2: [方法描述]
- 假设：[基于尝试1的新假设]
- 操作：[具体做了什么]
- 结果：❌ 失败 / ✅ 成功
- 学到：[这次尝试的收获]

### 尝试 3: [最终解决]
- 根本原因：[问题的本质]
- 解决方案：[具体修复]

## 预防措施
[如何避免类似问题再次发生]
```

### 决策记录 (decision_*.md)

```markdown
# 决策记录: [决策简述]

> 创建时间: YYYY-MM-DD
> 关联主文件: ../working_state.md
> 状态: 已决定 / 待讨论

## 决策摘要
<!-- 同步到主文件 -->
[一句话描述决策和理由]

## 背景
- 为什么需要做这个决策
- 当前面临的问题

## 备选方案

### 方案 A: [名称]
- 描述：[方案内容]
- 优点：[列出]
- 缺点：[列出]
- 成本/风险：[评估]

### 方案 B: [名称]
- 描述：[方案内容]
- 优点：[列出]
- 缺点：[列出]
- 成本/风险：[评估]

## 最终决策
- 选择：方案 X
- 理由：[为什么选这个]
- 权衡：[放弃了什么]

## 后续行动
- [ ] 需要执行的事项
```

---

## 工作流程

### 流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        任务开始                                   │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
         ┌───────────────────────────────┐
         │  创建 working_state.md        │
         │  定义目标、规划阶段             │
         └───────────────┬───────────────┘
                         │
                         ▼
    ┌────────────────────────────────────────────┐
    │              工作循环                        │
    │                                            │
    │  ┌──────────────────────────────────────┐ │
    │  │  1. 读取 working_state.md            │ │
    │  │     获取全局视野，刷新目标             │ │
    │  └──────────────┬───────────────────────┘ │
    │                 │                          │
    │                 ▼                          │
    │  ┌──────────────────────────────────────┐ │
    │  │  2. 需要详情？                        │ │
    │  │     按需读取 refs/xxx.md              │ │
    │  └──────────────┬───────────────────────┘ │
    │                 │                          │
    │                 ▼                          │
    │  ┌──────────────────────────────────────┐ │
    │  │  3. 执行工作                          │ │
    │  │     研究、编码、测试                   │ │
    │  └──────────────┬───────────────────────┘ │
    │                 │                          │
    │                 ▼                          │
    │  ┌──────────────────────────────────────┐ │
    │  │  4. 内容超过阈值？                    │ │
    │  │     创建引用文件                       │ │
    │  │     主文件保留摘要+路径                │ │
    │  └──────────────┬───────────────────────┘ │
    │                 │                          │
    │                 ▼                          │
    │  ┌──────────────────────────────────────┐ │
    │  │  5. 更新 working_state.md            │ │
    │  │     阶段状态、错误、发现摘要           │ │
    │  └──────────────┬───────────────────────┘ │
    │                 │                          │
    │                 └────────┐                 │
    │                          │ 继续            │
    └──────────────────────────┘                 │
                                                 │
                         ┌───────────────────────┘
                         │ 完成
                         ▼
         ┌───────────────────────────────┐
         │  会话结束                       │
         │  当前会话归档到 refs/session_   │
         │  更新主文件的历史会话引用        │
         └───────────────────────────────┘
```

### 步骤详解

#### 1. 任务启动

```bash
# 创建主文件和引用目录
touch working_state.md
mkdir -p refs
```

填写主文件：
- 目标声明
- 阶段规划
- 关键问题

#### 2. 工作循环

**每次重大操作前**：
```
Read working_state.md    # 刷新目标到注意力窗口
```

**需要详情时**：
```
Read refs/research_xxx.md    # 按需加载
```

**完成研究/分析后**：
```
if 内容 > 10 行:
    创建 refs/research_xxx.md    # 详细内容
    更新主文件                    # 摘要 + 引用路径
else:
    直接更新主文件               # 内容较少，无需拆分
```

**遇到错误时**：
```
记录到主文件的错误日志表

if 排查过程复杂:
    创建 refs/debug_xxx.md       # 详细排查过程
    主文件错误表添加引用链接
```

#### 3. 会话结束

```
1. 将"当前会话"内容移动到 refs/session_MMDD.md
2. 清空主文件的"当前会话"区域
3. 在"历史会话"添加引用链接
```

---

## 拆分决策指南

### 什么时候创建引用文件？

| 内容类型 | 阈值 | 动作 |
|---------|------|------|
| 研究笔记 | > 10 行详细内容 | → `refs/research_xxx.md` |
| 代码分析 | > 5 个文件的分析 | → `refs/analysis_xxx.md` |
| 问题排查 | > 2 次尝试 | → `refs/debug_xxx.md` |
| 会话日志 | 每个会话结束时 | → `refs/session_MMDD.md` |
| 重大决策 | 需要详细论证 | → `refs/decision_xxx.md` |

### 主文件保留什么？

**必须保留**：
- 目标声明
- 当前阶段
- 所有阶段的状态
- 关键决策（摘要）
- 所有错误（简要）
- 所有发现（摘要 + 引用）
- 当前会话进度
- 待办事项

**通过引用包含**：
- 详细研究笔记
- 详细排查过程
- 历史会话日志
- 深度分析报告
- 决策论证过程

---

## 最佳实践

### 1. 主文件黄金法则

```
行数 ≤ 200 行
每个摘要 ≤ 1-2 句话
引用路径始终完整
```

### 2. 摘要写作技巧

**好的摘要**：
```markdown
- **OAuth 2.0**: 授权码流程适合我们，已实现 → [详细](refs/research_oauth.md)
```
包含：主题 + 结论 + 状态 + 引用

**差的摘要**：
```markdown
- **OAuth 2.0**: 见详细笔记 → [详细](refs/research_oauth.md)
```
问题：缺少结论，必须读取引用才能了解内容

### 3. 引用文件开头标准化

每个引用文件开头包含：
```markdown
> 创建时间: YYYY-MM-DD
> 关联主文件: ../working_state.md
> 状态: [进行中/已完成]

## 摘要
[同步到主文件的内容]
```

### 4. 会话归档节奏

| 会话时长 | 处理方式 |
|---------|---------|
| < 2 小时 | 直接在主文件记录 |
| > 2 小时 | 创建 refs/session_MMDD.md |
| 多日任务 | 每日结束时归档 |

### 5. 错误处理三步走

```
ATTEMPT 1: 诊断 & 修复
  → 仔细阅读错误
  → 找出根本原因
  → 应用针对性修复

ATTEMPT 2: 换个方法
  → 同样的错误？换个方法
  → 不同的工具？不同的库？
  → 绝不重复完全相同的失败操作

ATTEMPT 3: 重新思考
  → 质疑假设
  → 搜索解决方案
  → 考虑更新计划

3 次失败后: 请求帮助
  → 解释尝试了什么
  → 分享具体错误
  → 询问指导
```

---

## 5 问题重启测试

通过阅读 `working_state.md` 回答这 5 个问题，验证上下文完整性：

| 问题 | 答案来源 |
|------|---------|
| 1. 我在哪？ | 当前阶段 |
| 2. 要去哪？ | 剩余阶段 |
| 3. 目标是什么？ | 目标声明 |
| 4. 学到了什么？ | 研究发现（摘要） |
| 5. 做了什么？ | 当前会话 + 历史会话引用 |

**关键**：前 4 个问题**只读主文件**就能回答。第 5 个问题的详情通过引用获取。

---

## 完整示例

### 场景：实现用户认证系统

#### 初始状态

**working_state.md**：
```markdown
# 工作状态

## 目标
为 Web 应用实现完整的用户认证系统，支持注册、登录、JWT 令牌

## 当前阶段
Phase 1: 需求理解

## 阶段进度
- [ ] Phase 1: 需求理解 | 🔄
- [ ] Phase 2: 技术选型 | ⏸️
- [ ] Phase 3: 核心实现 | ⏸️
- [ ] Phase 4: 测试验证 | ⏸️

## 关键问题
1. 使用 session 还是 JWT？ → 待定
2. 密码如何加密？ → 待定
3. 需要 OAuth 第三方登录吗？ → 待确认

## 关键决策
| 决策 | 理由 | 详情 |
|------|------|------|

## 研究发现

## 错误日志
| 错误 | 尝试 | 解决方案 | 详情 |
|------|------|---------|------|

## 当前会话
### 2026-01-22
- 14:00 任务开始，创建工作状态文件

## 历史会话

## 待办事项
- [ ] 确认是否需要 OAuth
- [ ] 研究 JWT vs Session
- [ ] 研究密码加密方案
```

#### Phase 1 完成后

研究了 JWT，内容较多，创建引用文件：

**refs/research_jwt.md**：
```markdown
# 研究笔记: JWT 认证

> 创建时间: 2026-01-22
> 关联主文件: ../working_state.md

## 摘要
JWT 适合无状态 API，使用 access + refresh 双令牌模式

## 详细发现

### JWT 结构
- Header: 算法和类型
- Payload: 用户数据（不放敏感信息）
- Signature: 签名验证

### 令牌策略
- Access Token: 15 分钟过期，用于 API 请求
- Refresh Token: 7 天过期，用于刷新 access token
- 存储: httpOnly cookie（防止 XSS）

### 安全考虑
- 不在 payload 放敏感数据
- 使用 HTTPS
- 实现 token 黑名单（登出时）

## 资源链接
- [JWT.io](https://jwt.io/)
- [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)

## 结论
推荐使用 JWT + 双令牌模式，适合我们的无状态 API 架构
```

**更新后的 working_state.md**：
```markdown
# 工作状态

## 目标
为 Web 应用实现完整的用户认证系统，支持注册、登录、JWT 令牌

## 当前阶段
Phase 2: 技术选型

## 阶段进度
- [x] Phase 1: 需求理解 | ✅
- [ ] Phase 2: 技术选型 | 🔄 ← 当前
- [ ] Phase 3: 核心实现 | ⏸️
- [ ] Phase 4: 测试验证 | ⏸️

## 关键问题
1. 使用 session 还是 JWT？ → **JWT**，适合无状态 API
2. 密码如何加密？ → **bcrypt**，工业标准
3. 需要 OAuth 第三方登录吗？ → 暂不需要

## 关键决策
| 决策 | 理由 | 详情 |
|------|------|------|
| 使用 JWT | 无状态，适合 API，易扩展 | [分析](refs/research_jwt.md) |
| bcrypt 加密 | 工业标准，自动加盐 | - |
| 双令牌模式 | 安全性与用户体验平衡 | [分析](refs/research_jwt.md) |

## 研究发现
- **JWT 认证**: access 15分钟 + refresh 7天，httpOnly cookie 存储 → [详细](refs/research_jwt.md)
- **密码加密**: bcrypt 自动加盐，cost factor 建议 12

## 错误日志
| 错误 | 尝试 | 解决方案 | 详情 |
|------|------|---------|------|

## 当前会话
### 2026-01-22
- 14:00 任务开始
- 14:30 研究 JWT vs Session，决定用 JWT
- 15:00 研究密码加密，决定用 bcrypt
- 15:30 Phase 1 完成，开始 Phase 2

## 历史会话

## 待办事项
- [x] 确认是否需要 OAuth → 暂不需要
- [x] 研究 JWT vs Session → JWT
- [x] 研究密码加密方案 → bcrypt
- [ ] 确定项目结构
- [ ] 选择具体的库/框架
```

#### 会话结束归档

**refs/session_0122.md**：
```markdown
# 会话日志: 2026-01-22

> 关联主文件: ../working_state.md

## 会话概要
- 完成 Phase 1（需求理解）
- 开始 Phase 2（技术选型）
- 关键决策：JWT + bcrypt

## 详细时间线
- 14:00 创建工作状态文件，规划阶段
- 14:30 研究 JWT，创建 refs/research_jwt.md
- 15:00 研究密码加密方案
- 15:30 更新主文件，标记 Phase 1 完成
- 16:00 会话结束

## 创建的文件
| 文件 | 说明 |
|------|------|
| working_state.md | 主工作状态文件 |
| refs/research_jwt.md | JWT 研究笔记 |

## 下次继续
- [ ] 确定项目结构
- [ ] 选择具体的库
- [ ] 开始 Phase 3 实现
```

**主文件归档更新**：
```markdown
## 当前会话
### 2026-01-23
- （新会话开始）

## 历史会话
- 2026-01-22: 完成 Phase 1，开始 Phase 2，决定 JWT + bcrypt → [日志](refs/session_0122.md)
```

---

## 适用场景

### 适合使用

- 多步骤任务（3+ 步骤）
- 研究性任务
- 项目开发
- 需要大量工具调用的任务（5+）
- 跨多个会话的长期任务

### 不需要使用

- 简单问答
- 单文件编辑
- 快速查询
- 一次性小任务

---

## 总结

Working State Pattern 的核心：

```
┌─────────────────────────────────────┐
│                                     │
│   主文件 = 注意力焦点 + 索引        │
│   引用文件 = 按需加载的详情         │
│                                     │
│   1 次 Read 获得全局视野            │
│   按需 Read 获取详细信息            │
│                                     │
│   指针不丢，详情按需                │
│                                     │
└─────────────────────────────────────┘
```

这种模式实现了上下文工程的核心目标：

- **外部化记忆**：重要信息持久化到文件系统
- **注意力操纵**：重读主文件刷新目标
- **错误持久化**：所有错误记录在案
- **结构化跟踪**：阶段状态清晰可见
- **按需加载**：只读取需要的详情

---

## 参考资料

- [Manus Context Engineering](https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus)
- [Anthropic: Effective harnesses for long-running agents](https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents)
